Assignment Briefing #1
Part A: Given the order class below, using Java create a class called OrderBook that provides efficient limit order
book capabilities.

public class Order {
	// private variables
	long id;
	double price;
	char side; // should be B or A
	long size;
	String sym;
	//constructor
	public Order(long orderid, double orderprice, char orderside, long ordersize, String ordersym)
	{
		id=orderid;
		price=orderprice;
		size=ordersize;
		side=orderside;
		sym=ordersym;
	}

	//methods
	long getId() { return id; }
	double getPrice(){ return price; }
	long getSize(){ return size; }
	String getSym(){ return sym; }
	char getSide() { return side; }
}


The use cases to be supported include:
1. Given an order object add it to the order Book. Order additions are expected to occur extremely
regularly.
2. Given an orderid, remove an order from the Book. Order deletions are expected to occur at
approximately 60% of the rate of order additions.
3. Given an orderid, and a new size, modify an existing order in the book to use the new size.
4. Given a side and an integer-valued level, return the price for that level, where level 1 represents the
best price for a given side. For example if side=’B’ and level=1, the best bid price should be returned.
If side=’B’ and level=2 are requested, the next best bid price should be returned. Note that higher
bid prices, are considered best and are associated with level 1, yet on the ask side of the order book
lower prices are considered best.
5. Given a side and an integer-valued level, return the total size available for that level, where level 1
represents the best price for a given side.
6. Given a side return all the orders from that side of the book, in level- and time-order.


Part B: Please suggest (but don’t implement) modifications or additions to the Order and/or OrderBook classes to
make them better suited to support real-life, latency-sensitive trading operations.
